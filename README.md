# BlackT
black tea -> 红茶  

就是我每天晚上回家喝的茶，以此来作为这个项目的名字  

人工智能现在的研究大多是通过各种匹配算法来实现的，比如验证码识别：不断地输入图片和图片结果的对应数据，设计不同size的筛选矩阵，通过输入图片与筛选矩阵的计算，得到该图片与对应数据的近似度，再经由迭代运算调整筛选矩阵中每个数值的大小，从而获得一个相对准确的矩阵，以此来验证未知图片的对应数据，然而这样的计算是有缺陷的，那就是严重依赖输入图片与图片结果的对应数据，必须严格正确，而且占用的计算量也比较大，真正的短板在于，识别验证码的只能识别验证码，换一个比如识别水果的需求，就需要完全重做，重新计算，在现实生活中，各种需求都是不断变化、数据不断更新的，图片的像素有多有少，色彩饱和程度有高有低，换一个摄像头几乎就要重新跑一遍数据，这样的智能，局限性还是太大了吧。  

图像识别本质上是一次信息的转化，把计算机不能理解的(x, y, z)三维点集转化为计算机同样不能理解的文字/代码/符号，本质上是一个信息衰减的过程，各种优秀的智能算法则是在这个衰减的过程中尽量减少有效信息的衰减，以及减少计算所需要的步骤，这样，一个又快又准的智能算法就训练完成了，但由于算法是严重依赖原始数据，假如原始数据所包含的不够全面，或者不够准确，那就直接gg了。而真正的人脑是如何处理信息的呢？那就是反射。大脑接收到一些信息，然后多个神经元把这些一起传递给下一级的神经元，相应的信息——虽然我们至今不知道大脑是以什么样的结构存储这些信息的——某几个神经元得到匹配的结论，那么就返回匹配，某些神经元没有匹配到，则直接停止传递消息，然后大脑根据这些返回匹配消息的神经元进行判定，该做出什么决定，并且，由于此次成功匹配了，那么就加粗加快这方面的连接，并减低没有匹配的信息与这些结论信息的联系。在这个过程中，真正牛逼的地方在于，速度非常快，大脑其实只需要接收部分信息就可以直接给出答案，只要看过1+1=2，那么，无论这个字是斜的弯的扭的，中文的英文的阿拉伯数字的，大脑分析都能迅速得出结论，这个等式的对的，但输入的是什么呢？可能只是书本上的图像和老师的语音，而苹果、梨子这些具象的物体又能加深大脑的理解。是的，比起这些人工智能，大脑真实太神奇太强大了。  

参照大脑的结构，对人工智能又有什么样的启发呢？首先，从一个信息到另一个信息的过程，不应该是衰减，而是在某一过程中发现不需要而舍弃；大脑使用分枝多线的方法加快查找速度，并且在这过程中可以只使用少量信息；训练可以使信息的转化向某一方面定向强化。其次，整体上，大脑在一个时间断内只能执行一个任务，呈线性，但具体到某一个任务时执行多线并发，所谓深入思索，就是多线并发计算分析每一个链接的相关度。最后，数据在大脑中的存储是以一个网状结构存在的，视觉信息的获取是一个动态的过程，眼睛在某一时刻只能获取较为少量的信息，这些信息通过与大脑中的数据进行匹配，发现这是某些元素的一部分信息，再查看相邻的部分，是被遮挡了/没有其他信息了/其他的信息与众多元素中的某些元素比较匹配，如果能够得出某一个满意的结果，就直接返回结果，如果不能就继续搜集附近的其他信息。大脑处理信息需要明确的关联，所以需要眼睛能够尽可能地给出轮廓清晰的图像，以便于分析。由此，人眼捕获的图像是越清晰越好的。信息的集合A能够联系到另一个信息B上，但每一个信息A的子集对信息B的关联强度是不一致的，并且不同的子集对不同的信息B的强度都不同，所以类似的萌卡特罗搜索树，其实并没有一个真正适应范围广的决策树。  

以简单的五子棋作为切入点考虑，可以设想这样一个伪代码：  
```
求解（五子棋棋局）「  
    if(查找结果（五子棋棋局）== true)  
        return 结果  
    if(五子棋棋局 is 元数据）  
        return 猜测结果  
    子模块数组=检索（五子棋棋局）  
    return Max（求解（子模块1），求解（子模块2）...)  
」
```
显然，这是一个递归函数，描述了五子棋的下棋步骤：1.先从以往的经验中查找，看看是否有对应的解决办法，如果有，则直接返回解决办法（对于五子棋来说，就是下一步的落子）；2.如果经验没有答案，且棋局不能再细分——即该单位形成了一个最小的完整依赖项，那么就进行计算or猜测结果。什么是元数据？五子棋最小的细分单位肯定是每一个单位的点，但这样的点对下一步落子并没有很大的参考价值，就像图片的最小单位是每一个像素点，但知道了每一个像素点的rgb的值对识别这张图片并没有多少帮助，有帮助的是一些点集形成的线段甚至是图形——这就输多级神经网络的识别基础，这个最好是通过统计来得出最合适的线段、图形的size，得到的信息量最小的统计结果就是最好的元数据size。3.后两句则是实现递归，检索跟前面的查找不一样，查找需要的是具体的结果，这个可以通过经验获得，而检索则是找出最大相似度且有最优结果的元数据队列，这个最好是唯一的，但考虑到实际的情形，往往可能存在数个可能，此时，就需要分别求解，最终返回最佳结果。  

然后我们还需要一个猜测函数（这可能就是从鹦鹉到乌鸦的核心函数）：
```
猜测（元数据模块）「  
    拆分元数据模块  
    求解（拆分后子模块）  
」
```
这时候应该会有多个解的，但是寻求一个最优解or随机选择一个较优解作为结果返回，并将该猜测记录到猜测队列里面，假如该猜测的结果导致胜利则给予奖励并加入查找队列，假如导致失败，则给予惩罚并加入舍弃队列里面  


